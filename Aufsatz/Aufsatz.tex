\documentclass[12pt,a4paper,titlepage,onecolumn,ngerman,bibliography=totocnumbered]{scrartcl}

%META-INFORMATION
\author{Maximilian Moeller}
\title{Maximaler Fluss in Flussnetzwerken}
\subtitle{Proseminar Theoretische Informatik 2020}
\date{\today}

%PACKAGES
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{csquotes}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{microtype}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

%OPTIONS
%no "then" or "do" in algorithm
\renewcommand\algorithmicthen{}
\renewcommand\algorithmicdo{}
%
\theoremstyle{definition}
\newtheorem*{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Anmerkung}
%
\setquotestyle[quotes]{german}

%GRAPHING
\usepackage{tikz-network}
\usepackage{caption}
\usepackage{subcaption}

%BIBLATEX
\usepackage[style=alphabetic]{biblatex}
\addbibresource{../../references.bib}
%smaller URLs
\usepackage{url}
\renewcommand{\UrlFont}{\small\tt}

%ALIAS
\newcommand{\ff}{\textsc{Ford-Fulkerson}}
\newcommand{\pr}{Push/Relabel}

\begin{document}
\maketitle
\nocite{*}

\tableofcontents

\begin{abstract}
In dieser Ausarbeitung soll eine Zusammenfassung des Kapitels 26 \glqq Maximaler Fluss\grqq{} aus dem Buch \glqq Introduction to Algorithms\grqq{} \parencite{Cormen09} gegeben werden. 
Dabei soll insbesondere auf den \pr -Algorithmus eingegangen und ein Vergleich zum \ff -Algorithmus gezogen werden.
\medbreak
Die Fragestellung nach dem maximalen Fluss ist ein Problem aus der Graphentheorie, das
in vielen praktischen Fällen Anwendung findet. 
Überall dort, wo die Menge einer zwischen verschiedenen Punkten transportierten Ware maximiert werden soll, kann auf die hier entwickelten Lösungen zurückgegriffen werden. 
Als Beispiele seien die Informationsübertragung in Computernetzwerken oder der Flüssigkeitstransport in Rohrleitungssystemen genannt. 
\end{abstract}

\section{Grundlagen}
In diesem Abschnitt werden die grundlegenden Voraussetzungen geschaffen, um das Problem des maximalen Flusses sinnvoll formulieren zu können.
Darüber hinaus werden einige Konzepte erarbeitet, die für das Verständnis der Algorithmen unerlässlich sind.

\subsection{Flussnetzwerke}
Ein Flussnetzwerk ist ein gerichteter Graph $G = (V,E)$, in dem jeder Kante $(u,v) \in E$ durch eine Kapazitätsfunktion $c: V\times V\to\mathfrak{B}$ eine Kapazität $c(u,v) \geq 0$ zugeordnet ist.
Dabei ist häufig $\mathfrak{B} = \mathbb{N}$, seltener auch $\mathfrak{B} = \mathbb{Z}$ oder $\mathfrak{B} = \mathbb{R}$.
Im Folgenden soll deswegen $\mathfrak{B} = \mathbb{N}$ betrachtet werden.
Für $(u,v) \notin E$ sei $c(u,v) = 0$.
Außerdem fordern wir:
\begin{equation} \label{no_parallel}
\forall (u,v)\in V\times V: (u,v)\in E \Rightarrow (v,u)\notin E\\
\end{equation}
Wir verbieten also entgegengerichtete Kantenpaare.
Darüber hinaus darf es in einem Flussnetzwerk auch keine reflexiven Kanten -- also Kanten mit gleichem Start- und Zielknoten -- geben.
Statt zu zeigen, dass dies keine echten Einschränkungen sind, sei hier auf \cite[][S. 724 f.]{Cormen09} verwiesen.
\medbreak
Jedes Flussnetzwerk enthält zwei besondere Knoten: Eine Quelle $s$ und eine Senke $t$.
Der Einfachheit halber liege jeder Knoten $v \in V$ auf einem Pfad von $s$ nach $t$.\\
Abbildung \ref{fig:flow_network.1} zeigt ein Beispiel für ein Flussnetzwerk.

\subsection{Fluss in Flussnetzwerken}
Ein Fluss $f$ in einem Flussnetzwerk $G=(V,E)$ ist eine Funktion $f: V \times V \to \mathfrak{B}$.
Dabei muss ein Fluss drei besondere Bedingungen erfüllen:
\begin{align}
&\forall u,v\in V\colon (u,v)\notin E\Rightarrow f(u,v) = 0 \label{only_on_edges} \\
&\forall u,v\in V\colon 0\leq f(u,v)\leq c(u,v) \label{limited_by_capacity} \\
&\forall u\in V\setminus\{s,t\}\colon\sum_{v\in V} f(v,u) = \sum_{v\in V} f(u,v) \label{flow_continuation}
\end{align}
Die Eigenschaft \eqref{flow_continuation} trägt den Namen Flusserhaltung. 
Im Beispiel des Stromflusses entspricht sie der Kirchhoffschen Knotenregel.\\
Abbildung \ref{fig:flow_network.2} zeigt einen Fluss.

\begin{figure}
    \centering
    \begin{subfigure}[t]{.475\textwidth}
        \centering
        \begin{tikzpicture}
            \Vertex[label=$s$]{s}
            \Vertex[label=$u_1$, x=2, y=1]{1}
            \Vertex[label=$u_2$, x=2, y=-1]{2}
            \Vertex[label=$u_3$, x=4, y=1]{3}
            \Vertex[label=$u_4$, x=4, y=-1]{4}
            \Vertex[label=$t$, x=6, y=0]{t}
            \Edge[Direct, label=4](s)(1)
            \Edge[Direct, label=7](s)(2)
            \Edge[Direct, label=2](1)(3)
            \Edge[Direct, label=4](2)(3)
            \Edge[Direct, label=3](2)(4)
            \Edge[Direct, label=6](3)(t)
            \Edge[Direct, label=2](4)(t)
        \end{tikzpicture}
        \caption{Ein Flussnetzwerk $G$}
        \label{fig:flow_network.1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.475\textwidth}
        \centering
        \begin{tikzpicture}
            \Vertex[label=$s$]{s}
            \Vertex[label=$u_1$, x=2, y=1]{1}
            \Vertex[label=$u_2$, x=2, y=-1]{2}
            \Vertex[label=$u_3$, x=4, y=1]{3}
            \Vertex[label=$u_4$, x=4, y=-1]{4}
            \Vertex[label=$t$, x=6, y=0]{t}
            \Edge[Direct, label=1/4](s)(1)
            \Edge[Direct, label=2/7](s)(2)
            \Edge[Direct, label=1/2](1)(3)
            \Edge[Direct, label=4](2)(3)
            \Edge[Direct, label=2/3](2)(4)
            \Edge[Direct, label=1/6](3)(t)
            \Edge[Direct, label=2/2](4)(t)
        \end{tikzpicture}
        \caption{Ein Fluss $f$ in $G$ mit $\lvert f\rvert = 3$}
        \label{fig:flow_network.2}
    \end{subfigure}
    \caption{In der hier verwendeten Darstellung werden Kanten $(u,v)$ mit $f(u,v)/c(u,v)$ beschrifet. Ist $f(u,v) = 0$, so wird nur die Kapazität angegeben.}
    \label{fig:flow_network}
\end{figure}

\subsection{Wert eines Flusses}
Der Wert $\lvert f \rvert$ eines Flusses $f$ ist definiert als:
\begin{equation}\label{flow_value}
\lvert f \rvert := \sum_{u\in V} f(s,u) - \sum_{u\in V} f(u,s)
\end{equation}
Er entspricht also der Menge an Fluss, die aus der Quelle $s$ herausfließt.
Wegen \eqref{flow_continuation} also auch der Menge an Fluss, die in die Senke $t$ hineinfließt.
Häufig enthält ein Flussnetzwerk keine eingehenden Kanten zur Quelle, womit sich die Gleichung zu $\lvert f \rvert := \sum_{u\in V} f(s,u)$ vereinfacht.
Wir können nun das maximaler-Fluss-Problem formal definieren:

\begin{definition}
Im maximaler-Fluss-Problem ist ein Flussnetzwerk $G$ mit Quelle $s$ und Senke $t$ gegeben.
Gesucht wird ein Fluss $f$, dessen Wert $\lvert f\rvert$ maximal für dieses Flussnetzwerk ist.
\end{definition}
\begin{remark}    
Dieser Fluss muss nicht eindeutig bestimmt sein. %TODO Bild als Beweis
\end{remark}

\subsection{Restnetzwerke}
Restnetzwerke sind ein Konstrukt, das es uns erlauben wird effizient Kanten zu finden, auf denen der Fluss noch erhöht werden kann.
Restnetzwerke sind ebenfalls gerichtete Graphen. 
Sie existieren jedoch nicht für sich, sondern werden durch den Fluss in einem Flussnetzwerk induziert.
\medbreak
Sei $G=(V,E)$ ein Flussnetzwerk und $f$ ein Fluss in $G$.
Die Restkapazität einer Kante ist definiert als:
\begin{equation}\label{residual_capacity}
    c_{f}(u,v) = 
    \begin{cases}
        c(u,v) - f(u,v) & \text{falls $(u,v)\in E$}\\
        f(v,u) & \text{falls $(v,u) \in E$}\\
        0 & \text{sonst}
    \end{cases}
\end{equation}
Wegen \eqref{no_parallel} tritt immer nur genau einer dieser Fälle ein.
Daraus können wir die Menge der Restkanten definieren:
\begin{equation}\label{residual_edges}
    E_f = \{ (u,v) \in V \times V \mid c_{f}(u,v) > 0\}
\end{equation}
Dann ist das durch $f$ induzierte Restnetzwerk $G_f=(V,E_f)$.
Abbildung \ref{fig:residual_network} zeigt ein Beispiel dafür.
\bigbreak
Es ist wichtig zu verstehen, dass Restnetzwerke keine Flussnetzwerke sind, denn sie dürfen entgegengerichtete Kantenpaare enthalten.
Das hatten wir für Flussnetzwerke verboten.
Fließt entlang einer Kante $(u,v)$ in einem Flussnetzwerk $G$ ein Fluss $f$ mit $0 < f(u,v) < c(u,v)$, so gibt es im Restnetzwerk $G_f$ wegen \eqref{residual_capacity} zwei Kanten zwischen diesen Knoten.
Dabei stellt $c_f(u,v)$ diejenige Menge an Fluss dar, die noch über die Kante geschickt werden kann, ohne die Kapazitätsbeschränkung zu verletzen.
Dahingegen ist $c_f(v,u)$ die Menge, um die der Fluss auf $(u,v)$ reduziert werden kann.
Solche Reduzierungen des Flusses können lokal nötig sein, um den Fluss global zu erhöhen.
\bigbreak
Ganz analog zu Fluss in Flussnetzwerken können wir auch Fluss in Restnetzwerken definieren.
Ein Fluss in einem Restnetzwerk muss ebenfalls den Anforderungen \eqref{only_on_edges} - \eqref{flow_continuation} genügen.
Auch der Wert $\lvert f'\rvert$ eines Flusses $f'$ in einem Restnetzwerk ist analog zu \eqref{flow_value} definiert.

\begin{figure}
    \centering
    \begin{subfigure}[t]{.475\textwidth}
        \centering
        \begin{tikzpicture}
            \Vertex[label=$s$]{s}
            \Vertex[label=$v_1$, x=2, y=2]{1}
            \Vertex[label=$v_2$, x=2, y=-2]{2}
            \Vertex[label=$t$, x=4, y=0]{t}
            \Edge[Direct, label=3/3](s)(1)
            \Edge[Direct, label=2/3](s)(2)
            \Edge[Direct, label=1](2)(1)
            \Edge[Direct, label=3/7](1)(t)
            \Edge[Direct, label=2/2](2)(t)
        \end{tikzpicture}
        \caption{Fluss $f$ in einem Flussnetzwerk $G = (V,E)$}
        \label{fig:residual_network.1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{.475\textwidth}
        \centering
        \begin{tikzpicture}
            \Vertex[label=$s$]{s}
            \Vertex[label=$v_1$, x=2, y=2]{1}
            \Vertex[label=$v_2$, x=2, y=-2]{2}
            \Vertex[label=$t$, x=4, y=0]{t}
            \Edge[Direct, label=3](1)(s)
            \Edge[Direct, label=1, bend=15](s)(2)
            \Edge[Direct, label=2, bend=15](2)(s)
            \Edge[Direct, label=1](2)(1)
            \Edge[Direct, label=4, bend=15](1)(t)
            \Edge[Direct, label=3, bend=15](t)(1)
            \Edge[Direct, label=2](t)(2)
        \end{tikzpicture}
        \caption{durch $f$ induziertes Restnetzwerk $G_f = (V,E_f)$}
        \label{fig:residual_network.2}
    \end{subfigure}
    \caption{Induktion eines Restnetzwerkes}
    \label{fig:residual_network}
\end{figure}

\subsection{Erhöhung eines Flusses}
Sei $f$ ein Fluss im Flussnetzwerk $G = (V,E)$ und $f'$ ein Fluss in $G_f$.
Für die Erhöhung von $f$ um $f'$ schreiben wir $f \uparrow f'$ und definieren:
\begin{equation}
    (f \uparrow f')(u,v)=
    \begin{cases}
    f(u,v) + f'(u,v) - f'(v,u) & \text{falls $(u,v) \in E$}\\
    0 & \text{sonst}
    \end{cases}
\end{equation}
Diese Definition entspricht zunächst nur einer einfachen Intuition.
\textquote[{\cite[S. 730]{Cormen09}}]{Wir erhöhen den Fluss auf $(u, v)$ um $f'(u, v)$ und verringern ihn um $f'(v,u)$, da das Zurückfließenlassen eines Flusses auf einer entgegengerichteten Kante äquivalent dazu ist, den Fluss in dem ursprünglichen Netzwerk zu verringern.}
\medbreak
Die so erhaltene Funktion $f\uparrow f'$ erfüllt die Eigenschaften \eqref{only_on_edges} - \eqref{flow_continuation} -- ist also wieder ein Fluss -- und hat den Wert:
\begin{equation}\label{flow_incr}
    \lvert f\uparrow f' \rvert = \lvert f \rvert + \lvert f'\rvert
\end{equation}
Die Beweise für diese wichtigen Erkenntnisse würden den Rahmen dieser Zusammenfassung sprengen, sie sind jedoch sehr sehenswert.
Es sei daher auf \cite[][S. 730-732]{Cormen09} verwiesen.


\section{\ff -Algorithmen}
Zunächst soll die Klasse der \ff -Algorithmen erläutert werden.
Der Basisalgorithmus wurde von L. R. Ford Jr. und D. R. Fulkerson im Jahr 1956 vorgestellt.
Wir sprechen hier von einer Algorithmenklasse, weil die hier beschriebenen Ideen in vielen leicht abgewandelten Algorithmen Verwendung finden.
Diese unterschiedlichen Implementationsmöglichkeiten ergeben unterschiedliche Laufzeiten.

\subsection{Erweiterungspfade}
Die \ff -Algorithmen verwenden Pfade von $s$ nach $t$ im Restnetzwerk -- sogenannte Erweiterungspfade.
Entlang dieser Pfade kann dann ein Fluss definiert werden, um den der ursprüngliche Fluss im Flussnetzwerk erhöht wird.
\medbreak
Sei also $f$ ein Fluss im Flussnetzwerk $G$.
Mittels eines geeigneten Algorithmus wird zunächst ein Pfad $p$ von $s$ nach $t$ im Restnetzwerk $G_f$ bestimmt.
Dann lässt sich die Pfadkapazität wie folgt definieren:
\begin{equation}
    c_f(p) = min\{ c_f(u,v)\mid (u,v) \text{ liegt auf $p$}\}
\end{equation}
\medbreak
Und damit auch ein Fluss:
\begin{equation}
    f_p(u,v) = \begin{cases}c_f(p) & \text{falls $(u,v)$ auf $p$ liegt}\\0 & \text{sonst}\end{cases}
\end{equation}
\medbreak
Wegen \eqref{residual_edges} gilt offensichtlich $\lvert f_p\rvert > 0$.
Somit erhalten wir einen neuen Fluss $f\uparrow f_p$ mit $\lvert f\uparrow f_p \rvert = \lvert f \rvert + \lvert f_p\rvert > \lvert f\rvert$. %TODO reference Flusserhöhung

\subsection{\ff -Basisalgorithmus}
Mit den bisher gewonnenen Kenntnissen ist es uns jetzt möglich den \ff -Basisalgorithmus nachzuvollziehen.
Als Hinweis zur Schreibweise sei gesagt, dass wir den Fluss auf einer Kante als Eigenschaft dieser Kante auffassen und über den Punktoperator darauf zugreifen.
\begin{algorithm}[H]
    \caption{\ff (G,s,t)}
    \label{alg:ff}
\begin{algorithmic}[1]
\For{jede Kante $(u,v) \in G.E$}
    \State $(u,v).f = 0$
\EndFor
\While{es existiert ein Pfad $p$ von $s$ nach $t$ in $G_f$}
    \State $c_{f}(p) =$ min\{$c_{f}(u,v) \mid (u,v)$ liegt auf $p$\}
    \For{jede Kante $(u,v)$ von $p$}
        \If{$(u,v) \in G.E$}
            \State $(u,v).f = (u,v).f + c_{f}(p)$
        \Else
            \State $(v,u).f = (v,u).f - c_{f}(p)$
        \EndIf
    \EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}
Zunächst initialisieren wir allen Fluss mit dem Wert $0$.
Anschließend erhöhen wir den Fluss entlang eines Erweiterungspfades um die Pfadkapazität und fahren so lange fort, wie es noch Erweiterungspfade gibt.

\subsection{Analyse des \ff -Basisalgorithmus}
Man sieht leicht, dass die so beschriebene Funktion $f$ bei Terminierung tatsächlich ein Fluss ist.
Schwieriger hingegen ist die Frage, ob $f$ auch ein maximaler Fluss ist.
Sie lässt sich mithilfe des \textbf{maxflow-mincut-Theorems} beantworten, dessen Beweis wir hier auslassen.
Kurz zusammengefasst stellt dieses Theorem den Zusammenhang zwischen Flüssen in Flussnetzwerken und Schnitten in Flussnetzwerken her.
Ein Schnitt ist eine besondere Partitionierung des Flussnetzwerks in zwei Teilmengen, von denen eine die Quelle $s$ und die andere die Senke $t$ enthält.
Unter anderem besagt das \textbf{maxflow-mincut-Theorem}:
\begin{equation}
    \lvert f\rvert\text{ ist maximal} \Leftrightarrow \text{es existiert kein Erweiterungspfad in $G_{f}$}
\end{equation}
Da wir für die Kantenkapazitäten im Flussnetzwerk natürliche Zahlen annehmen, wächst der Fluss in jeder Iteration des Algorithmus um mindestens eine Einheit.
Offensichtlich muss ein maximaler Fluss auch einen Wert aus $\mathbb{N}$ haben und somit terminiert der Algorithmus nach endlich vielen Schritten mit einem korrekten Ergebnis.
Auch für Kantenkapazitäten aus $\mathbb{Q}$ sind diese Beobachtungen interessant.
Für ein solches Flussnetzwerk kann man alle Kapazitäten mit dem Hauptnenner multiplizieren und so das Netzwerk \glqq skalieren\grqq{}.
Dann führt man den Algorithmus auf dem skalierten Flussnetzwerk aus und skaliert das Ergebnis zurück, indem man es durch den Hauptnenner dividiert.
Dieses Vorgehen lässt sich jedoch nicht auf jeden Zahlenbereich ausweiten.
Ford und Fulkerson konnten ein Flussnetzwerk mit Kantenkapazitäten aus $\mathbb{R}$ finden, für welches ihr Algorithmus nicht nur nicht terminiert, sondern der Fluss noch nicht einmal gegen einen maximalen Fluss konvergiert.
\medbreak
In Hinblick auf die Laufzeit des Algorithmus ist vor allem relevant, wie wir den Pfad $p$ bestimmen.
Mit einer geeigneten Datenstruktur und Breitensuche geben \cite{Cormen09} dafür $\mathcal{O}(E)$ an.
Wir hatten bereits beobachtet, dass wir für ein Flussnetzwerk mit einem maximalen Fluss $f'$ höchstens $\lvert f'\rvert$ Iterationen berechnen müssen.
Als Gesamtlaufzeit ergibt sich somit $\mathcal{O}(E\cdot\lvert f'\rvert)$
Dass in diesem Spezialfall die Laufzeit nicht nur von der Größe der Eingabe, sondern auch von der Größe der Ausgabe abhängt, ist ein Nachteil des Basisalgorithmus.
Er entsteht dadurch, dass die Reihenfolge, in der wir die Erweiterungspfade wählen entscheident ist.
Wenn wir den Erweiterungspfad nicht beliebig, sondern als einen kürzesten Pfad zwischen $s$ und $t$ wählen, erhalten wir den Edmonds-Karp-Algorithmus.
Benutzen wir Breitensuche für die Bestimmung eines solchen kürzesten Pfades, so verbessert sich die Laufzeit auf $\mathcal{O}(V\cdot E^2)$.

\section{\pr -Algorithmen}
Während die \ff -Algorithmen global nach einem Erweiterungspfad suchen, arbeiten \pr -Algorithmen wesentlich lokaler.
Sie betrachten stets nur einen Knoten und seine direkte Umgebung gleichzeitig.
Auch bei den \pr -Algorithmen gibt es mehrere Implementationsmöglichkeiten, die verschiedene Laufzeiten mit sich bringen.
Wir werden hier ausschließlich den Basisalgorithmus betrachten.
Zunächst wird dabei eine Datenstruktur initialisiert. 
Dann werden so lange Push- oder Relabel-Operationen ausgeführt, bis keine ausführbare Operation verbleibt.

\subsection{Grundlagen}
\pr -Algorithmen verletzen zeitweise die Flusserhaltung \eqref{flow_continuation}.
Statt in jedem Iterationsschritt einen gültigen Fluss zu erzeugen, verwenden sie Vorflüsse.
Ein Vorfluss ist ein Fluss, der lediglich eine schwächere Form der Flusserhaltung erfüllen muss:
\begin{equation}\label{eq:preflow}
    \forall u\in V\setminus\{s\}:\sum_{v\in V}f(v,u)\geq\sum_{v\in V}f(u,v)
\end{equation}
In einen Knoten $u$ kann also mehr Fluss hineinfließen, als aus ihm hinaus fließt.
Die Differenz dieser Mengen wird der Flussüberschuss $e(u)$ genannt:
\begin{equation}\label{eq:flow_excess}
    e(u) = \sum_{v\in V}f(v,u) -\sum_{v\in V}f(u,v)
\end{equation}
In den Knoten kann also ein beliebig großer Flussüberschuss gespeichert werden.
Ist $e(u)>0$, so sagen wir $u$ ist überflutet.
Wir werden sehen, wie der Flussüberschuss im Laufe des Algorithmus immer weiter in Richtung Senke geschoben (gepusht) wird.
Sobald die maximale Menge an Fluss von $s$ nach $t$ fließt, muss der Algorithmus dann nur noch den verbliebenen Flussüberschuss in allen Knoten wieder zurück zur Quelle schicken.
\medbreak
Neben dem Flussüberschuss gibt es noch eine weitere Größe.
Die Höhe $h(u)$ eines Knotens $u$ bestimmt, welche Operationen wir wie ausführen können.
Wir fixieren folgende Höhen: $h(s) = \lvert V\rvert$ und $h(t) = 0$.
Alle anderen Knoten beginnen mit Höhe $0$, steigen jedoch im Laufe des Algorithmus an.
Flussüberschuss wird ausschließlich von Knoten größerer Höhe zu Knoten geringerer Höhe gepusht.
Das schließt jedoch nicht aus, dass nicht auch von einem Knoten geringerer Höhe Fluss zu einem Knoten größerer Höhe fließt.
Sei $G=(V,E)$ ein Flussnetzwerk und $f$ ein Vorfluss in $G$.
Wir fordern weiterhin von der Höhenfunktion $h:V\to\mathbb{N}$:
\begin{equation}\label{eq:height_function}
    \forall (u,v)\in E_f: h(u)\leq h(v) + 1
\end{equation}
Wir beobachten für später auch die Kontraposition:
\begin{equation}\label{eq:contraposition_height}
    \forall u,v\in V: h(u) > h(v) + 1\Rightarrow (u,v) \not\in E_f
\end{equation}

\subsection{Die Push-Operation}
Wir werden sowohl für die Push-, als auch später für die Relabel-Operation Voraussetzungen festlegen, die erfüllt sein müssen um diese Operationen anwenden zu können.
Die Push-Operation wird verwendet, um Flussüberschuss von einem Knoten zu einem anderen zu drücken.
Wir können \textsc{Push}$(u,v)$ anwenden, wenn $u$ überflutet ist, die Restkapazität $c_f(u,v) > 0$ ist und $h(u) = h(v) + 1$ gilt.
Die ersten beiden Bedingungen sind trivial. 
Wie sollten wir Fluss von $u$ nach $v$ drücken, wenn $u$ nicht überflutet wäre oder die Kante $(u,v)$ bereits gesättigt wäre.
Mit der dritten Bedingung legen wir fest, dass wir Fluss stets nur über eine Kante pushen, die zu einem Knoten mit einer um eine Einheit niedrigeren Höhe führt.
Dies ergibt sich direkt aus \eqref{eq:contraposition_height}, wo wir gesehen haben, dass es keine Kanten im Restnetzwerk zu einem Knoten geben kann, dessen Höhen um mehr als eine Einheit niedriger ist.
Solange es sich bei $h$ also tatsächlich um eine Höhenfunktion handelt, wäre ein Push über mehr als eine Höheneinheit also unzulässig.
\begin{algorithm}[H]
    \caption{\textsc{Push}$(u,v)$}
    \label{alg:push}
\begin{algorithmic}[1]
\State{\textbf{// Anwendbar wenn:} $u.e > 0$, $c_{f}(u,v)>0$, und $u.h=v.h + 1$.}
\State{\textbf{// Aktion:} Drücke $\Delta_{f}(u,v) =$ min$(u.e,c_{f}(u,v))$ Flusseinheiten von $u$ nach $v$.}
\State{}
\State{$\Delta_{f}(u,v) =$ min$(u.e,c_{f}(u,v))$}
\If{$(u,v)\in E$}
    \State{$(u,v).f = (u,v).f +\Delta_{f}(u,v)$}
\Else
    \State{$(v,u).f = (v,u).f -\Delta_{f}(u,v)$}
\EndIf
\State{$u.e = u.e - \Delta_{f}(u,v)$}
\State{$v.e = v.e + \Delta_{f}(u,v)$}
\end{algorithmic}
\end{algorithm}
Wir wählen $\Delta_{f}(u,v)$ als das Minimum aus Flussüberschuss in $u$ und verbliebener Restkapazität $c_f(u,v)$.
Danach verändern wir den Vorfluss auf der gewählten Kante und passen die Überschüsse an.

\subsection{Die Relabel-Operation}
Wir haben bereits gesehen, wie wir Flussüberschuss von einem Knoten zum nächsten bewegen können.
Es kann allerdings vorkommen, dass ein Knoten überflutet ist und keine gültige Push-Operation für ihn existiert.
In diesem Fall wenden wir die Relabel-Operation auf den Knoten an, die seine Höhe wachsen lässt -- wir markieren $u$ um.
Bedingungen für die Ausführung von \textsc{Relabel}$(u)$ sind also, dass $e(u) > 0$ ist und $\forall (u,v)\in E_f: h(u) < h(v)$ gilt.
Ist nämlich die Höhe aller Knoten, zu denen Restkanten führen höher als die von $u$, so können wir den Flussüberschuss in $u$ durch keine Push-Operation verringern.
\begin{algorithm}[H]
    \caption{\textsc{Relabel}$(u)$}
    \label{alg:relabel}
\begin{algorithmic}[1]
\State{\textbf{// Anwendbar wenn:} $u.e > 0$, und $u.h \leq v.h$ für alle $v \in V$ mit $(u,v)\in E_f$.}
\State{\textbf{// Aktion:} setze u.h auf einen höheren Wert.}
\State{}
\State{$u.h = 1 +$min\{$v.h \mid (u,v)\in E_f$\}}
\end{algorithmic}
\end{algorithm}
Wegen $e(u) = \sum_{v\in V}f(v,u) -\sum_{v\in V}f(u,v) > 0$ muss es mindestens einen Knoten $v$ geben mit $f(v,u) > 0$.
Daraus folgt direkt, dass $c_f(u,v) > 0$ und damit $(u,v)\in E_f$.
\textquote[{\cite[S. 753]{Cormen09}}]{Die Operation \textsc{Relabel}$(u)$ weist $u$ also die größte Höhe zu, die nach den Beschränkungen der Höhenfunktionen erlaubt ist.}
Da wir die Höhenfunktion nur in der Relabel-Operation verändern, können wir uns also sicher sein, niemals \eqref{eq:height_function} zu verletzen.

\subsection{\pr -Algorithmus}
\newpage
\printbibliography
\end{document}
